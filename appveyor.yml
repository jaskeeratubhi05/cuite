version: 2.0.{build}
branches:
  only:
  - master

environment:
   matrix:
      # Visual Studio 2017
      - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
      # Visual Studio 2015
      - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015

install:
- ps: |
    Function Get-IniContent {  
        <#  
        .Synopsis  
            Gets the content of an INI file  
          
        .Description  
            Gets the content of an INI file and returns it as a hashtable  
          
        .Notes  
            Author        : Oliver Lipkau <oliver@lipkau.net>  
            Blog        : http://oliver.lipkau.net/blog/  
            Source        : https://github.com/lipkau/PsIni 
                          http://gallery.technet.microsoft.com/scriptcenter/ea40c1ef-c856-434b-b8fb-ebd7a76e8d91 
            Version        : 1.0 - 2010/03/12 - Initial release  
                          1.1 - 2014/12/11 - Typo (Thx SLDR) 
                                             Typo (Thx Dave Stiff) 
          
            #Requires -Version 2.0  
          
        .Inputs  
            System.String  
          
        .Outputs  
            System.Collections.Hashtable  
          
        .Parameter FilePath  
            Specifies the path to the input file.  
          
        .Example  
            $FileContent = Get-IniContent "C:\myinifile.ini"  
            -----------  
            Description  
            Saves the content of the c:\myinifile.ini in a hashtable called $FileContent  
      
        .Example  
            $inifilepath | $FileContent = Get-IniContent  
            -----------  
            Description  
            Gets the content of the ini file passed through the pipe into a hashtable called $FileContent  
      
        .Example  
            C:\PS>$FileContent = Get-IniContent "c:\settings.ini"  
            C:\PS>$FileContent["Section"]["Key"]  
            -----------  
            Description  
            Returns the key "Key" of the section "Section" from the C:\settings.ini file  
          
        .Link  
            Out-IniFile  
        #>  
      
        [CmdletBinding()]  
        Param(  
            [ValidateNotNullOrEmpty()]  
            [ValidateScript({(Test-Path $_) -and ((Get-Item $_).Extension -eq ".ini")})]  
            [Parameter(ValueFromPipeline=$True,Mandatory=$True)]  
            [string]$FilePath  
        )  
      
        Begin  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function started"}  
          
        Process  
        {  
            Write-Verbose "$($MyInvocation.MyCommand.Name):: Processing file: $Filepath"  
              
            $ini = @{}  
            switch -regex -file $FilePath  
            {  
                "^\[(.+)\]$" # Section  
                {  
                    $section = $matches[1]  
                    $ini[$section] = @{}  
                    $CommentCount = 0  
                }  
                "^(;.*)$" # Comment  
                {  
                    if (!($section))  
                    {  
                        $section = "No-Section"  
                        $ini[$section] = @{}  
                    }  
                    $value = $matches[1]  
                    $CommentCount = $CommentCount + 1  
                    $name = "Comment" + $CommentCount  
                    $ini[$section][$name] = $value  
                }   
                "(.+?)\s*=\s*(.*)" # Key  
                {  
                    if (!($section))  
                    {  
                        $section = "No-Section"  
                        $ini[$section] = @{}  
                    }  
                    $name,$value = $matches[1..2]  
                    $ini[$section][$name] = $value  
                }  
            }  
            Write-Verbose "$($MyInvocation.MyCommand.Name):: Finished Processing file: $FilePath"  
            Return $ini  
        }  
          
        End  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function ended"}  
    } 

    Function Out-IniFile {  
        <#  
        .Synopsis  
            Write hash content to INI file  
          
        .Description  
            Write hash content to INI file  
          
        .Notes  
            Author        : Oliver Lipkau <oliver@lipkau.net>  
            Blog        : http://oliver.lipkau.net/blog/  
            Source        : https://github.com/lipkau/PsIni 
                          http://gallery.technet.microsoft.com/scriptcenter/ea40c1ef-c856-434b-b8fb-ebd7a76e8d91 
            Version        : 1.0 - 2010/03/12 - Initial release  
                          1.1 - 2012/04/19 - Bugfix/Added example to help (Thx Ingmar Verheij)  
                          1.2 - 2014/12/11 - Improved handling for missing output file (Thx SLDR) 
          
            #Requires -Version 2.0  
          
        .Inputs  
            System.String  
            System.Collections.Hashtable  
          
        .Outputs  
            System.IO.FileSystemInfo  
          
        .Parameter Append  
            Adds the output to the end of an existing file, instead of replacing the file contents.  
          
        .Parameter InputObject  
            Specifies the Hashtable to be written to the file. Enter a variable that contains the objects or type a command or expression that gets the objects.  
  
        .Parameter FilePath  
            Specifies the path to the output file.  
       
         .Parameter Encoding  
            Specifies the type of character encoding used in the file. Valid values are "Unicode", "UTF7",  
             "UTF8", "UTF32", "ASCII", "BigEndianUnicode", "Default", and "OEM". "Unicode" is the default.  
          
            "Default" uses the encoding of the system's current ANSI code page.   
          
            "OEM" uses the current original equipment manufacturer code page identifier for the operating   
            system.  
       
         .Parameter Force  
            Allows the cmdlet to overwrite an existing read-only file. Even using the Force parameter, the cmdlet cannot override security restrictions.  
          
         .Parameter PassThru  
            Passes an object representing the location to the pipeline. By default, this cmdlet does not generate any output.  
                  
        .Example  
            Out-IniFile $IniVar "C:\myinifile.ini"  
            -----------  
            Description  
            Saves the content of the $IniVar Hashtable to the INI File c:\myinifile.ini  
          
        .Example  
            $IniVar | Out-IniFile "C:\myinifile.ini" -Force  
            -----------  
            Description  
            Saves the content of the $IniVar Hashtable to the INI File c:\myinifile.ini and overwrites the file if it is already present  
          
        .Example  
            $file = Out-IniFile $IniVar "C:\myinifile.ini" -PassThru  
            -----------  
            Description  
            Saves the content of the $IniVar Hashtable to the INI File c:\myinifile.ini and saves the file into $file  
  
        .Example  
            $Category1 = @{“Key1”=”Value1”;”Key2”=”Value2”}  
        $Category2 = @{“Key1”=”Value1”;”Key2”=”Value2”}  
        $NewINIContent = @{“Category1”=$Category1;”Category2”=$Category2}  
        Out-IniFile -InputObject $NewINIContent -FilePath "C:\MyNewFile.INI"  
            -----------  
            Description  
            Creating a custom Hashtable and saving it to C:\MyNewFile.INI  
        .Link  
            Get-IniContent  
        #>  
      
        [CmdletBinding()]  
        Param(  
            [switch]$Append,  
          
            [ValidateSet("Unicode","UTF7","UTF8","UTF32","ASCII","BigEndianUnicode","Default","OEM")]  
            [Parameter()]  
            [string]$Encoding = "Unicode",  
 
          
            [ValidateNotNullOrEmpty()]  
            [ValidatePattern('^([a-zA-Z]\:)?.+\.ini$')]  
            [Parameter(Mandatory=$True)]  
            [string]$FilePath,  
          
            [switch]$Force,  
          
            [ValidateNotNullOrEmpty()]  
            [Parameter(ValueFromPipeline=$True,Mandatory=$True)]  
            [Hashtable]$InputObject,  
          
            [switch]$Passthru  
        )  
      
        Begin  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function started"}  
          
        Process  
        {  
            Write-Verbose "$($MyInvocation.MyCommand.Name):: Writing to file: $Filepath"  
          
            if ($append) {$outfile = Get-Item $FilePath}  
            else {$outFile = New-Item -ItemType file -Path $Filepath -Force:$Force}  
            if (!($outFile)) {Throw "Could not create File"}  
            foreach ($i in $InputObject.keys)  
            {  
                if (!($($InputObject[$i].GetType().Name) -eq "Hashtable"))  
                {  
                    #No Sections  
                    Write-Verbose "$($MyInvocation.MyCommand.Name):: Writing key: $i"  
                    Add-Content -Path $outFile -Value "$i=$($InputObject[$i])" -Encoding $Encoding  
                } else {  
                    #Sections  
                    Write-Verbose "$($MyInvocation.MyCommand.Name):: Writing Section: [$i]"  
                    Add-Content -Path $outFile -Value "[$i]" -Encoding $Encoding  
                    Foreach ($j in $($InputObject[$i].keys | Sort-Object))  
                    {  
                        if ($j -match "^Comment[\d]+") {  
                            Write-Verbose "$($MyInvocation.MyCommand.Name):: Writing comment: $j"  
                            Add-Content -Path $outFile -Value "$($InputObject[$i][$j])" -Encoding $Encoding  
                        } else {  
                            Write-Verbose "$($MyInvocation.MyCommand.Name):: Writing key: $j"  
                            Add-Content -Path $outFile -Value "$j=$($InputObject[$i][$j])" -Encoding $Encoding  
                        }  
                      
                    }  
                    Add-Content -Path $outFile -Value "" -Encoding $Encoding  
                }  
            }  
            Write-Verbose "$($MyInvocation.MyCommand.Name):: Finished Writing to file: $path"  
            if ($PassThru) {Return $outFile}  
        }  
          
        End  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function ended"}  
    }  
      
    $webclient = New-Object System.Net.WebClient  
    # Allow Remote Desktop  
    Write-Host "Builds require a Remote Desktop Connection (RDP) to continue..."  
    $blockRdp = $true; iex ($webclient.DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))  
      
    if ($env:APPVEYOR_BUILD_WORKER_IMAGE -eq "Visual Studio 2015")
    {
        # Microsoft Visual Studio 2013 Premium  
        $logFilePath = "$($env:TEMP)\VS2013Premium.txt"  
        Write-Host "Installing Microsoft Visual Studio 2013 Premium..."  
        $process = (Start-Process -FilePath "appveyor build dependencies\en_visual_studio_premium_2013_with_update_5_x86_web_installer_6815734.exe" -ArgumentList "/Passive /NoRestart /Log $logFilePath" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 0)  
        {  
          Get-Content $logFilePath  
          throw "Command failed with exit code $exitCode."  
        }  
        del $logFilePath  
        Write-Host "Visual Studio 2013 Premium successfully installed" -ForegroundColor Green  

        # Microsoft Visual Studio 2013 Coded UI Test Plugin for Silverlight  
        Write-Host "Downloading Microsoft Visual Studio 2013 Coded UI Test Plugin for Silverlight..."  
        $msiFilePath = "$($env:USERPROFILE)\UITestPluginForSilverlightVS2013.msi"  
        $logFilePath = "$($env:TEMP)\UITestPluginForSilverlightVS2013.txt"  
        $webclient.DownloadFile('https://prachiboramsft.gallerycdn.vsassets.io/extensions/prachiboramsft/microsoftvisualstudio2013codeduitestpluginforsilve/1.0/1482140133605/133666/1/UITestPluginForSilverlightVS2013.msi', $msiFilePath)  
        Write-Host "Installing Microsoft Visual Studio 2013 Coded UI Test Plugin for Silverlight..."  
        $process = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i $msiFilePath /quiet /l*v $logFilePath" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 0)  
        {  
          Get-Content $logFilePath  
          throw "Command failed with exit code $exitCode."  
        }  
        del $msiFilePath  
        del $logFilePath  
        Write-Host "Visual Studio 2013 Coded UI Test Plugin for Silverlight successfully installed" -ForegroundColor Green  
      
        # Microsoft Visual Studio 2015 Enterprise  
        $logFilePath = "$($env:TEMP)\VS2015Enterprise.txt"  
        Write-Host "Installing Microsoft Visual Studio 2015 Enterprise..."  
        $process = (Start-Process -FilePath "appveyor build dependencies\en_visual_studio_enterprise_2015_with_update_3_x86_x64_web_installer_8922986.exe" -ArgumentList "/Passive /NoRestart /Log $logFilePath" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 3010)  
        {  
          Get-Content $logFilePath  
          throw "Command failed with exit code $exitCode."  
        }  
        del $logFilePath  
        Write-Host "Visual Studio 2015 Enterprise successfully installed" -ForegroundColor Green  

        # Microsoft Visual Studio 2015 Coded UI Test Plugin for Silverlight  
        Write-Host "Downloading Microsoft Visual Studio 2015 Coded UI Test Plugin for Silverlight..."  
        $msiFilePath = "$($env:USERPROFILE)\UITestPluginForSilverlightVS2015.msi"  
        $logFilePath = "$($env:TEMP)\UITestPluginForSilverlightVS2015.txt"  
        $webclient.DownloadFile('https://atinbansal.gallerycdn.vsassets.io/extensions/atinbansal/microsoftvisualstudio2015codeduitestpluginforsilve/1.0/1482142639885/189320/1/UITestPluginForSilverlightVS2015.msi', $msiFilePath)  
        Write-Host "Installing Microsoft Visual Studio 2015 Coded UI Test Plugin for Silverlight..."  
        $process = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i $msiFilePath /quiet /l*v $logFilePath" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 0)  
        {  
          Get-Content $logFilePath  
          throw "Command failed with exit code $exitCode."  
        }  
        del $msiFilePath  
        del $logFilePath  
        Write-Host "Visual Studio 2015 Coded UI Test Plugin for Silverlight successfully installed" -ForegroundColor Green  
      
        # Microsoft Silverlight 5 Toolkit - December 2011  
        Write-Host "Downloading Microsoft Silverlight 5 Toolkit - December 2011..."  
        $msiFilePath = "$($env:USERPROFILE)\Silverlight_5_Toolkit_December_2011.msi"  
        $logFilePath = "$($env:TEMP)\Silverlight_5_Toolkit_December_2011.txt"  
        $webclient.DownloadFile('https://github.com/MicrosoftArchive/SilverlightToolkit/releases/download/5/Silverlight_5_Toolkit_December_2011.1.msi', $msiFilePath)  
        Write-Host "Installing Microsoft Silverlight 5 Toolkit - December 2011..."  
        $process = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i $msiFilePath /quiet /l*v $logFilePath" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 0)  
        {  
          Get-Content $logFilePath  
          throw "Command failed with exit code $exitCode."  
        }  
        del $msiFilePath  
        del $logFilePath  
        Write-Host "Microsoft Silverlight 5 Toolkit - December 2011 successfully installed" -ForegroundColor Green  
      
        # Microsoft Silverlight 5 Developer Runtime for Windows (64 bit)  
        Write-Host "Downloading Microsoft Silverlight 5 Developer Runtime for Windows (64 bit)..."  
        $exeFilePath = "$($env:USERPROFILE)\Silverlight_Developer_x64.exe"  
        $retry_attempts = 3  
        for($i=0; $i -lt $retry_attempts; $i++){  
            try {  
                $webclient.DownloadFile('http://download.microsoft.com/download/1/F/6/1F637DB3-8EF9-4D96-A8F1-909DFD7C5E69/50428.00/Silverlight_Developer_x64.exe', $exeFilePath)  
                break  
            }  
            Catch [Exception]{  
                Start-Sleep 1  
            }  
        }  
        Write-Host "Installing Microsoft Silverlight 5 Developer Runtime for Windows (64 bit)..."  
        $process = (Start-Process -FilePath $exeFilePath -ArgumentList "/q" -Wait -Passthru)  
        $exitCode = $process.ExitCode  
        if ($exitCode -ne 0)  
        {  
          throw "Command failed with exit code $exitCode."  
        }  
        del $exeFilePath  
        Write-Host "Microsoft Silverlight 5 Developer Runtime for Windows (64 bit) successfully installed" -ForegroundColor Green  
    }

    # Google Chrome  
    Write-Host "Downloading Google Chrome..."  
    $msiFilePath = "$($env:USERPROFILE)\GoogleChromeStandaloneEnterprise.msi"  
    $logFilePath = "$($env:TEMP)\GoogleChromeStandaloneEnterprise.txt"  
    $webclient.DownloadFile('https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7B7ACD904C-E309-ADA4-8671-783B10D723FD%7D%26lang%3Den%26browser%3D4%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers/edgedl/chrome/install/GoogleChromeStandaloneEnterprise.msi', $msiFilePath)  
    Write-Host "Installing Google Chrome..."  
    $process = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i $msiFilePath /quiet /l*v $logFilePath" -Wait -Passthru)  
    $exitCode = $process.ExitCode  
    if ($exitCode -ne 0)  
    {  
      Get-Content $logFilePath  
      throw "Command failed with exit code $exitCode."  
    }  
    del $msiFilePath  
    del $logFilePath  
    Write-Host "Google Chrome successfully installed" -ForegroundColor Green  
      
    # Mozilla Firefox 47.0.1  
    Write-Host "Downloading Mozilla Firefox 47.0.1..."  
    $exeFilePath = "$($env:USERPROFILE)\Firefox Setup 47.0.1.exe"  
    $retry_attempts = 3  
    for($i=0; $i -lt $retry_attempts; $i++){  
        try {  
            $webclient.DownloadFile('http://ftp.mozilla.org/pub/mozilla.org/firefox/releases/47.0.1/win32/es-ES/Firefox%20Setup%2047.0.1.exe', $exeFilePath)  
            break  
        }  
        Catch [Exception]{  
            Start-Sleep 1  
        }  
    }  
    Write-Host "Installing Mozilla Firefox 47.0.1..."  
    $process = (Start-Process -FilePath $exeFilePath -ArgumentList "-ms" -Wait -Passthru)  
    $exitCode = $process.ExitCode  
    if ($exitCode -ne 0)  
    {  
      throw "Command failed with exit code $exitCode."  
    }  
    del $exeFilePath  
    Write-Host "Mozilla Firefox 27.0.1 successfully installed" -ForegroundColor Green  
      
    # Disable Firefox First Run Import Settings and Data Wizard  
    Write-Host "Disabling Mozilla Firefox Profile Migrator..."  
    $ProgramFiles = ${Env:ProgramFiles(x86)}  
    $FilePath = $ProgramFiles + "\Mozilla Firefox\override.ini"  
    if (!(test-path ($FilePath)))  
    {  
      # create the override.ini per https://developer.mozilla.org/en/Command_Line_Options  
      $err=@()  
      New-Item -type file -force $FilePath -ErrorVariable err | Out-Null  
      if (!($err.count -eq 0))  
      {  
        throw "Failed to create override.ini."  
      }  
    }  
      
    # read in the override.ini file  
    $iniData = Get-IniContent $FilePath  
      
    if (!($iniData.XRE))  
    {  
      $iniData.XRE = @{}  
    }  
      
    if (!($iniData.XRE.EnableProfileMigrator -eq 0))  
    {  
      $iniData.XRE.EnableProfileMigrator = 0  
      Out-IniFile -InputObject $iniData -FilePath $FilePath -Append  
    }  
    Write-Host "Mozilla Firefox Profile Migrator disabled" -ForegroundColor Green  
      
    # Selenium components for Coded UI Cross Browser Testing Version 1.7  
    Write-Host "Downloading Selenium components for Coded UI Cross Browser Testing Version 1.7..."  
    $msiFilePath = "$($env:USERPROFILE)\CodedUITestCrossBrowserSetup.msi"  
    $logFilePath = "$($env:TEMP)\CodedUITestCrossBrowserSetup.txt"  
    $webclient.DownloadFile('https://atinbansal.gallerycdn.vsassets.io/extensions/atinbansal/seleniumcomponentsforcodeduicrossbrowsertesting/1.7/1482138134269/85444/13/CodedUITestCrossBrowserSetup.msi', $msiFilePath)  
    Write-Host "Installing Selenium components for Coded UI Cross Browser Testing Version 1.7..."  
    $process = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i $msiFilePath /quiet /l*v $logFilePath" -Wait -Passthru)  
    $exitCode = $process.ExitCode  
    if ($exitCode -ne 0)  
    {  
      Get-Content $logFilePath  
      throw "Command failed with exit code $exitCode."  
    }  
    del $msiFilePath  
    del $logFilePath  
    Write-Host "Selenium components for Coded UI Cross Browser Testing Version 1.7 successfully installed" -ForegroundColor Green  
      
    # Chrome driver 2.27
    Write-Host "Downloading Chrome driver 2.27..."  
    $zipPath = "$($env:USERPROFILE)\chromedriver_win32.zip"  
    $webclient.DownloadFile('http://chromedriver.storage.googleapis.com/2.27/chromedriver_win32.zip', $zipPath)  
    Write-Host "Installing Chrome driver 2.27..."  
    7z x $zipPath -y -o"$($ProgramFiles)\Common Files\Microsoft Shared\VSTT\Cross Browser Selenium Components" | Out-Null  
    Write-Host "Chrome driver 2.27 successfully installed" -ForegroundColor Green  

    if(-not $screen_resolution) {  
      $screen_resolution = '1024x768'  
    }  
      
    Write-Host "Setting up active Desktop..." -ForegroundColor cyan  
    # https://github.com/FreeRDP/FreeRDP/wiki/CommandLineInterface  
    #$zipPath = "$($env:USERPROFILE)\wfreerdp-1.1.zip"  
    #$webclient.DownloadFile('http://av1southus4workers.blob.core.windows.net/downloads/tools/wfreerdp-1.1.zip', $zipPath)  
    #7z x $zipPath -y -o"$env:TEMP" | Out-Null  
    #Write-Host "Starting Remote Desktop session..."  
    #$psw = (get-itemproperty -path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -name DefaultPassword).DefaultPassword  
    #Start-Process "$env:TEMP\wfreerdp.exe" -ArgumentList '/v:127.0.0.1','/u:appveyor',"/p:$psw","/size:$screen_resolution" -WindowStyle Hidden  
    #Write-Host "Waiting for RDP to connect..."  
    #Start-Sleep -s 5  
    #Write-Host "Desktop ready"-ForegroundColor green  
      
    # Load remote sources with full trust  
    if ($env:APPVEYOR_BUILD_WORKER_IMAGE -eq "Visual Studio 2015")  
    {  
        $ConfigFilePath = ${Env:ProgramFiles(x86)} + "\Microsoft Visual Studio 12.0\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe.config"  
    }
    else
    {
        $ConfigFilePath = ${Env:ProgramFiles(x86)} + "\Microsoft Visual Studio 14.0\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe.config"  
    }
    [xml]$Configuration = Get-Content -Path $ConfigFilePath  
    $element = $Configuration.CreateElement('loadFromRemoteSources')  
    $element.Attributes.Append($Configuration.CreateAttribute("enabled"))  
    $element.enabled = "true"  
    $Configuration.configuration.runtime.AppendChild($element)  
    $Configuration.Save($ConfigFilePath)  

    # Apply low integrity label on html files to mark them as accessible from an Enhanced Protected Mode process
    # http://blogs.msdn.com/b/ieinternals/archive/2012/06/20/loading-local-files-in-enhanced-protected-mode-in-internet-explorer-10.aspx
    # This circumvents the "Open File - Security Warning" dialog that appears when exes (applications under test) are launched
    Start-Process -FilePath icacls.exe -ArgumentList '"%appveyor_build_folder%" /setintegritylevel (CI)(OI)Medium' -NoNewWindow
    if ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode)  }
    
    if ($env:APPVEYOR_BUILD_WORKER_IMAGE -eq "Visual Studio 2015")
    {
        Write-Host "Rebooting machine..." -ForegroundColor Green  
        Restart-Computer -Force  
        Start-Sleep -s 10  
    }
     
    # $blockRdp = $true; iex ($webclient.DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"  
assembly_info:
  patch: true
  file: src\CommonAssemblyInfo.cs
  assembly_version: '{version}.0'
  assembly_file_version: '{version}.0'
  assembly_informational_version: '{version}-beta'
nuget:
  disable_publish_on_pr: true
build_script:
- cmd: >-
    setx see_mask_nozonechecks 1 /m

    call "%VS140COMNTOOLS%VsDevCmd.bat"

    msbuild.exe src\build.proj /t:Build;Pack

    REM icacls src\Sut.HtmlTest\bin\Release\TestHtmlPage.html /setintegritylevel (CI)(OI)Low

    powershell -Command "(Get-Content src\Local_CUITv10.runsettings) -replace '{APPVEYOR_BUILD_FOLDER}', '%APPVEYOR_BUILD_FOLDER%' | Out-File -encoding UTF8 src\Local_CUITv10.runsettings"

    powershell -Command "(Get-Content src\Local_CUITv11.runsettings) -replace '{APPVEYOR_BUILD_FOLDER}', '%APPVEYOR_BUILD_FOLDER%' | Out-File -encoding UTF8 src\Local_CUITv11.runsettings"

    powershell -Command "(Get-Content src\Local_CUITv12.runsettings) -replace '{APPVEYOR_BUILD_FOLDER}', '%APPVEYOR_BUILD_FOLDER%' | Out-File -encoding UTF8 src\Local_CUITv12.runsettings"

    powershell -Command "(Get-Content src\Local_CUITv14.runsettings) -replace '{APPVEYOR_BUILD_FOLDER}', '%APPVEYOR_BUILD_FOLDER%' | Out-File -encoding UTF8 src\Local_CUITv14.runsettings"

    powershell -Command "(Get-Content src\Local_CUITv15.runsettings) -replace '{APPVEYOR_BUILD_FOLDER}', '%APPVEYOR_BUILD_FOLDER%' | Out-File -encoding UTF8 src\Local_CUITv15.runsettings"

test_script:
- ps: |
    Function RunTests {
        [CmdletBinding()]  
        Param(  
            [ValidateNotNullOrEmpty()]  
            [Parameter(Mandatory=$True)]  
            [string]$vsTestConsoleExe,  

            [ValidateNotNullOrEmpty()]  
            [Parameter(Mandatory=$True)]  
            [string]$testDllFilePattern,  

            [ValidateNotNullOrEmpty()]  
            [Parameter(Mandatory=$True)]  
            [string]$runSettingsFilePath  
        )  
      
        Begin  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function started"}  
          
        Process  
        {  
            Write-Verbose "$($MyInvocation.MyCommand.Name):: Processing: $vsTestConsoleExe $testDllFilePattern"  
            
            $parameters = ""

            Get-ChildItem `
                -Path "$($env:APPVEYOR_BUILD_FOLDER)\src" `
                -File `
                -Recurse `
                -Filter *.dll |
                where-object FullName -Like $testDllFilePattern |
                ForEach-Object {
                    $parameters = $parameters + "`"" + $_.FullName + "`" ";
                }  
            
            $processInfo = New-Object System.Diagnostics.ProcessStartInfo 
            $processInfo.FileName = "$vsTestConsoleExe" 
            $processInfo.RedirectStandardError = $true 
            $processInfo.RedirectStandardOutput = $true 
            $processInfo.UseShellExecute = $false 
            $processInfo.Arguments = "$parameters /Settings:`"$runSettingsFilePath`" /logger:Appveyor" 
            $process = New-Object System.Diagnostics.Process 
            $process.StartInfo = $processInfo 
            $process.Start() | Out-Null 
            $stdout = $process.StandardOutput.ReadToEnd()
            $stderr = $process.StandardError.ReadToEnd()
            $process.WaitForExit() 
            Write-Host $stdout 
            Write-Host $stderr 
            $exitCode = $process.ExitCode  
            Write-Host $exitCode 
            if ($exitCode -ne 0)  
            {  
              throw "Command failed with exit code $exitCode."  
            }  

            Write-Verbose "$($MyInvocation.MyCommand.Name):: Finished Processing: $vsTestConsoleExe $testDllFilePattern"  
        }  
          
        End  
            {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function ended"}  
    }

    if ($env:APPVEYOR_BUILD_WORKER_IMAGE -eq "Visual Studio 2015")
    {
        Write-Host "Tests require a Remote Desktop Connection (RDP) to continue..."  
        $webclient = New-Object System.Net.WebClient  
        $blockRdp = $true; iex ($webclient.DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))  
    }

    $vsTestConsoleExe = "C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe"
    RunTests $vsTestConsoleExe "*bin\Release\VS2010\net40\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv10.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2012\net40\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv11.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2012\net45\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv11.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2013\net40\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv12.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2013\net45\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv12.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2015\net40\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv14.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2015\net45\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv14.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2017\net40\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv15.runsettings"
    RunTests $vsTestConsoleExe "*bin\Release\VS2017\net45\*Test.dll" "$($env:APPVEYOR_BUILD_FOLDER)\src\Local_CUITv15.runsettings"
    

artifacts:
- path: '*.nupkg'
  name: NuGet
deploy:
- provider: NuGet
  api_key:
    secure: g78LUTxqGPAeE0eliIasoLHL2fGxcWkPcojy06FwWUqtRUK3E4ToYSQ34GlEUYj5
  artifact: NuGet
on_finish:
- ps: |
    # Collect test results  
    Write-Host "Publishing test results..."  
    Get-ChildItem '.\TestResults\*\In' -Recurse -Include '*.*' | % { Push-AppveyorArtifact $_.FullName -FileName $(-Join $(Split-Path (Split-Path (Split-Path $_.FullName -Parent) -Parent ) -Leaf) + '_' + $_.Name) -DeploymentName TestResult }  

    # Collect UI test log  
    Write-Host "Publishing UI test log..."  
    Push-AppveyorArtifact $env:temp\UITestLogs\LastRun\UITestLog.html -DeploymentName UITestLog  

    Write-Host "Build finished."  
on_failure:
- ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))